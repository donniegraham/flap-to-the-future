<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Flap to the future</title>

  <link rel="icon" type="image/png" href="/favicon-96x96.png" sizes="96x96" />
  <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
  <link rel="shortcut icon" href="/favicon.ico" />
  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png" />
  <link rel="manifest" href="/site.webmanifest" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.2/p5.min.js"></script>
  <style>
    /* Basic reset and body styling */
    body {
      margin: 0;
      overflow: hidden; /* Prevent scrollbars */
      font-family: 'Arial Black', Gadget, sans-serif; /* Chunky font */
      touch-action: none; /* Prevent default touch actions */
      background-color: #000010; /* Very dark blue/black fallback */
      user-select: none; /* Prevent text selection globally */
      -webkit-user-select: none; /* Safari */
      -moz-user-select: none; /* Firefox */
      -ms-user-select: none; /* IE/Edge */
    }

    /* Game container */
    #game {
      position: relative;
      width: 100vw;
      height: 100vh;
      z-index: 1;
      /* Background color now primarily handled by p5 canvas */
      overflow: hidden; /* Hide obstacles moving off-screen */
    }

    /* Score Area Container */
    .score-container {
        position: absolute;
        top: 20px;
        left: 20px;
        z-index: 10;
        display: flex; /* Align items horizontally */
        align-items: center; /* Align items vertically */
        background: rgba(0, 0, 0, 0.5); /* Optional: background for the whole area */
        padding: 5px 10px;
        border-radius: 10px;
        /* user-select is inherited from body */
    }

    /* Score display */
    .score {
      color: white;
      font-size: 1.8rem;
      font-weight: bold;
      text-align: center;
      text-shadow: 0 0 5px #ff0; /* Yellow glow */
      margin-right: 10px;
      margin-left: 10px; /* Space after pause button */
    }

     /* Banner for Game Over / Start */
    .banner {
      position: absolute;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 0, 0, 0.7);
      padding: 60px 40px 30px 40px; /* Increased top padding */
      border-radius: 10px;
      color: white;
      font-weight: bold;
      z-index: 11; /* Above score and pause overlay */
      text-align: center;
      font-size: 1.5rem; /* Base size for text within */
      line-height: 1.4;
      position: relative; /* Needed for absolute positioning inside */
      overflow: hidden;
      min-width: 300px; /* Ensure banner is wide enough */
    }


    /* DeLorean styling */
    .delorean {
      position: absolute;
      /* Start position and transition for entry */
      left: 0px; /* Start at left edge */
      transform: translateX(0) rotate(0deg); /* Initial transform */
      opacity: 0; /* Start hidden */
      transition: left 1s cubic-bezier(0.25, 1, 0.5, 1),
                  opacity 0.5s ease-in,
                  transform 0.4s ease-out; /* Slower tilt */
      /* top: set by JavaScript */
      width: 100px;
      height: 37px;
      background-image: url('https://i.postimg.cc/9XBXnvZH/delorean.png');
      background-size: cover;
      background-position: center;
      background-repeat: no-repeat;
      z-index: 5;
    }
    /* Add error handling for the image */
    .delorean[style*="url('https://i.postimg.cc/9XBXnvZH/delorean.png')"] {
        background-image: url('https://i.postimg.cc/9XBXnvZH/delorean.png'), linear-gradient(grey, darkgrey); /* Fallback gradient */
    }

    /* Booster Effect Styling */
    .delorean::after {
        content: '';
        position: absolute;
        left: -25px;
        top: 50%;
        transform: translateY(-50%);
        width: 40px;
        height: 15px;
        background: linear-gradient(to left, rgba(0, 220, 255, 0), rgba(0, 200, 255, 0.8), #0cf);
        border-radius: 50% 0 0 50%;
        opacity: 0;
        transition: opacity 0.15s ease-out;
        z-index: -1;
    }
    .delorean.booster-active::after {
        opacity: 1;
    }


    /* Obstacle styling (Futuristic Skyscrapers) */
    .obstacle-pipe {
      position: absolute;
      width: 80px;
      /* background set by JS */
      background-repeat: repeat, no-repeat; /* Repeat texture, don't repeat base */
      background-position: center center;
      background-size: auto, cover; /* Texture size auto, base gradient cover */
      z-index: 3;
      border: 1px solid rgba(0, 150, 150, 0.5);
      /* Transition for vertical movement */
      transition: transform 0.1s linear;
    }
    .obstacle-top {
        top: 0;
    }
    .obstacle-bottom {
        bottom: 0;
    }

    /* Score Logo and Text Styling */
    .score-logo {
        width: 40px;
        height: 40px;
        margin-left: 8px;
        animation: bounce 1.5s ease-in-out infinite;
    }

    .score-text {
        color: white;
        font-size: 1.1rem;
        font-weight: bold;
        text-shadow: 0 0 4px #0ff; /* Cyan glow */
        margin-right: 5px;
    }

    /* Styling for large background logo in banner */
    .banner-bg-logo {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        object-fit: contain;
        opacity: 0.3;
        z-index: 1;
        pointer-events: none;
    }

    /* Styling for text content wrapper within banner */
    .banner-text-content {
        position: relative; /* Needed to establish stacking context */
        z-index: 2; /* Ensure text is above the background logo */
        display: flex; /* Use flexbox for vertical layout */
        flex-direction: column; /* Stack items vertically */
        align-items: center; /* Center items horizontally */
    }

    /* Styling for Game Over Score Display */
     .current-score {
        font-size: 2.8rem; /* Large score */
        color: #ffd700; /* Gold */
        text-shadow: 0 0 5px #000, 0 0 10px #ff8c00; /* Dark shadow + orange glow */
        margin-top: 0; /* Reset margin */
        margin-bottom: 5px; /* Space below current score */
        font-weight: bold;
        line-height: 1.1;
    }
     .top-score {
        font-size: 1.2rem; /* Smaller font for top score */
        color: #eee; /* Lighter color */
        margin-bottom: 0; /* Remove bottom margin */
        font-weight: normal;
         text-shadow: 0 0 3px #000;
    }


    /* Bouncing animation keyframes */
    @keyframes bounce {
        0%, 100% { transform: translateY(0); }
        50% { transform: translateY(-5px); }
    }

    /* Coin Styling (Base - used for default DMC coin) */
    .coin {
        position: absolute;
        width: 35px;
        height: 35px;
        background-image: url('https://img.cryptorank.io/coins/de_lorean1738931968450.png');
        background-size: contain;
        background-repeat: no-repeat;
        background-position: center;
        border-radius: 50%;
        box-shadow: 0 0 8px rgba(255, 215, 0, 0.7);
        z-index: 4;
        animation: spin 1.2s linear infinite;
    }

    /* Bitcoin Coin Styling */
    .bitcoin-coin {
        position: absolute;
        width: 35px;
        height: 35px;
        background-image: url('https://upload.wikimedia.org/wikipedia/commons/thumb/4/46/Bitcoin.svg/1200px-Bitcoin.svg.png'); /* Bitcoin Logo */
        background-size: contain;
        background-repeat: no-repeat;
        background-position: center;
        border-radius: 50%;
        box-shadow: 0 0 10px rgba(255, 255, 0, 0.9); /* Brighter Yellow Glow */
        z-index: 4;
        animation: spin 1.0s linear infinite; /* Slightly faster spin? */
    }

    /* Sui Coin Styling */
    .sui-coin {
        position: absolute; width: 35px; height: 35px;
        background-image: url('https://assets.crypto.ro/logos/sui-sui-logo.png');
        background-size: contain; background-repeat: no-repeat; background-position: center;
        border-radius: 50%; box-shadow: 0 0 10px rgba(0, 200, 255, 0.9); /* Cyan Glow */
        z-index: 4; animation: spin 1.1s linear infinite;
    }

    /* Wal Coin Styling */
    .wal-coin {
        position: absolute; width: 35px; height: 35px;
        background-image: url('https://s2.coinmarketcap.com/static/img/coins/64x64/36119.png'); /* Updated URL */
        background-size: cover; background-repeat: no-repeat; background-position: center;
        border-radius: 50%; box-shadow: 0 0 10px rgba(200, 200, 200, 0.9); /* Grey Glow */
        z-index: 4; animation: spin 1.3s linear infinite;
    }

    /* Lofi Coin Styling */
    .lofi-coin {
        position: absolute; width: 35px; height: 35px;
        background-image: url('https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcR50QoB3S_JoW6Uf8aQNvEUAdet59kqRAkqfg&s');
        background-size: cover; /* Cover might look better for non-square */
        background-repeat: no-repeat; background-position: center;
        border-radius: 50%; box-shadow: 0 0 10px rgba(255, 105, 180, 0.9); /* Pink/Lofi Glow? */
        z-index: 4; animation: spin 1.4s linear infinite; /* Different spin speed? */
    }


    /* Keyframes for coin spin */
    @keyframes spin {
        from { transform: rotateY(0deg); }
        to { transform: rotateY(360deg); }
    }

    /* REMOVED: Fuel Can Styling */


    /* Portal Styling */
    #portal {
        position: absolute;
        left: 40px;
        transform: translateY(-50%) scale(1);
        top: 50%;
        width: 80px;
        height: 120px;
        background: radial-gradient(ellipse at center, rgba(0,150,255,0.1) 0%, rgba(0,100,255,0.6) 60%, #05f 100%);
        border-radius: 50%;
        border: 2px solid #0af;
        box-shadow: 0 0 15px #0cf, 0 0 30px #0af, inset 0 0 10px #5ef;
        z-index: 6;
        opacity: 1;
        transform-origin: center center;
        animation: pulse 2s infinite ease-in-out;
        display: block;
        pointer-events: none;
    }

    /* Portal closing animation */
    #portal.portal-closing {
        animation: shrinkFade 1.5s ease-out forwards, pulse 2s infinite ease-in-out;
    }

    @keyframes pulse {
        0%, 100% { box-shadow: 0 0 15px #0cf, 0 0 30px #0af, inset 0 0 10px #5ef; }
        50% { box-shadow: 0 0 25px #0df, 0 0 45px #0bf, inset 0 0 15px #7ff; }
    }

    /* Keyframes for shrinking/fading portal */
    @keyframes shrinkFade {
        to {
            transform: translateY(-50%) scale(0);
            opacity: 0;
        }
    }

    /* Reset Button Styling */
    .reset-button { /* Also used for Resume button */
        position: absolute;
        top: 15px;
        left: 15px;
        z-index: 2; /* Ensure above bg logo */
        display: inline-flex;
        align-items: center;
        justify-content: center;
        padding: 10px 15px;
        background-color: #0af;
        color: white;
        border: 1px solid #5ef;
        border-radius: 8px;
        font-family: 'Arial Black', Gadget, sans-serif;
        font-size: 1rem;
        font-weight: bold;
        cursor: pointer;
        text-shadow: 0 0 3px #000;
        transition: background-color 0.2s ease, box-shadow 0.2s ease;
        box-shadow: 0 0 5px #0cf, 0 0 10px #0af;
    }
    .reset-button:hover, .reset-button:focus {
        background-color: #5df;
        box-shadow: 0 0 8px #0cf, 0 0 15px #0af;
        outline: none;
    }
    /* Style for SVG inside Reset Button */
    .reset-button svg {
        width: 0.9em;
        height: 0.9em;
        stroke: currentColor;
        stroke-width: 2.5;
        stroke-linecap: round;
        stroke-linejoin: round;
        fill: none;
        margin-right: 8px; /* Space between icon and text */
    }

    /* Share Button Styling */
    .share-button {
        position: absolute;
        top: 15px; /* Position near top */
        right: 15px; /* Position near right */
        display: inline-flex;
        align-items: center;
        justify-content: center;
        /* Styles to match reset-button */
        padding: 10px 15px;
        background-color: #0af;
        color: white;
        border: 1px solid #5ef;
        border-radius: 8px;
        font-family: 'Arial Black', Gadget, sans-serif;
        font-size: 1rem;
        font-weight: bold;
        cursor: pointer;
        text-shadow: 0 0 3px #000;
        transition: background-color 0.2s ease, box-shadow 0.2s ease;
        box-shadow: 0 0 5px #0cf, 0 0 10px #0af;
        line-height: 1;
        z-index: 2;
    }
    .share-button:hover, .share-button:focus {
        background-color: #5df; /* Match hover */
        box-shadow: 0 0 8px #0cf, 0 0 15px #0af; /* Match hover */
        outline: none;
    }
    /* Style for SVG inside share button */
    .share-button svg {
        width: 1em; /* Match reset button SVG size */
        height: 1em;
        fill: currentColor;
        vertical-align: middle; /* Consistent alignment */
        display: inline-block;
        margin-left: 8px; /* Match reset button margin */
    }


    /* Footer Styling */
    .social-footer {
        position: absolute;
        bottom: 15px;
        left: 50%;
        transform: translateX(-50%);
        z-index: 10;
        list-style: none;
        padding: 0;
        margin: 0;
        display: flex;
        gap: 15px;
    }
    .social-footer li { display: inline-block; }
    .social-footer a { display: block; }
    /* Smaller social icons */
    .social-footer a svg {
        display: block;
        width: 32px; /* Was 38px */
        height: 32px; /* Was 38px */
    }
    .social-footer a svg path[fill="#5E6569"] {
        transition: fill 0.3s ease;
    }
    .social-footer a:hover svg path[fill="#5E6569"] {
        fill: #0ff; /* Cyan hover color */
    }
     .social-footer a[aria-label="GitHub"] svg path {
         fill: #5E6569; /* Ensure initial fill */
         transition: fill 0.3s ease;
     }
     .social-footer a[aria-label="GitHub"]:hover svg path {
         fill: #0ff; /* Ensure hover fill */
     }


    /* Pause UI Styling */
     .ui-button { /* General style for UI buttons */
        background-color: rgba(0, 0, 0, 0.5);
        border: 1px solid #aaa;
        color: white;
        padding: 5px 10px;
        border-radius: 5px;
        cursor: pointer;
        font-size: 1.2rem; /* Adjusted size */
        line-height: 1;
        min-width: 30px; /* Ensure minimum width */
        text-align: center;
    }
    .ui-button:hover {
        background-color: rgba(50, 50, 50, 0.6);
    }
    #pauseButton {
        margin-right: 10px; /* Space before score number */
    }

    .overlay {
        position: fixed; /* Cover viewport */
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.8); /* Darker overlay */
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 20; /* Above everything else except maybe banner */
    }
    .pause-content {
        text-align: center;
        background: rgba(30, 30, 50, 0.85);
        padding: 40px 60px;
        border-radius: 15px;
        box-shadow: 0 0 20px #0ff;
    }
    .paused-score {
        font-size: 2.5rem;
        color: #ffd700;
        text-shadow: 0 0 5px #000, 0 0 10px #ff8c00;
        margin-bottom: 25px;
        font-weight: bold;
    }

    /* SoundCloud Embed Styling */
    .soundcloud-embed {
        position: absolute;
        top: 15px;
        right: 15px;
        z-index: 10;
        width: 200px;
        background: rgba(0,0,0,0.3);
        border-radius: 5px;
        padding: 5px;
    }
    .soundcloud-embed iframe {
        display: block;
        width: 100%;
        height: 80px;
        border: none;
    }
    .soundcloud-embed div {
        font-size: 8px !important;
        color: #cccccc !important;
        line-break: anywhere !important;
        word-break: normal !important;
        overflow: hidden !important;
        white-space: nowrap !important;
        text-overflow: ellipsis !important;
        font-family: Interstate, Lucida Grande, Lucida Sans Unicode, Lucida Sans, Garuda, Verdana, Tahoma, sans-serif !important;
        font-weight: 100 !important;
        margin-top: 3px;
    }
     .soundcloud-embed div a {
         color: #cccccc !important;
         text-decoration: none !important;
     }

    @media (max-width: 767px) { /* Matches JS breakpoint */
        .soundcloud-embed {
            display: none; /* Hide the embed */
        }
        /* Adjust button positions on mobile if needed */
        .banner { padding-top: 60px; padding-left: 15px; padding-right: 15px; }
        .reset-button { top: 10px; left: 10px; padding: 8px 10px; font-size: 0.8rem;}
        .share-button { top: 10px; right: 10px; padding: 8px 10px; font-size: 0.8rem;} /* Match padding */
        .current-score { font-size: 2.2rem; }
        .top-score { font-size: 1rem; }
    }

    /* REMOVED: Fuel Bar Styling */


    /* p5.js canvas styling (for background) */
    canvas {
      position: absolute;
      top: 0;
      left: 0;
      z-index: 0; /* Behind all game elements */
    }
  </style>
</head>
<body>
  <div id="game">
     <div class="score-container">
        <button id="pauseButton" class="ui-button" aria-label="Pause">❚❚</button>
        <div class="score" id="score">0</div>
        <span class="score-text">$DMC</span> <img src="https://img.cryptorank.io/coins/de_lorean1738931968450.png"
             class="score-logo"
             alt="Coin Logo"
             onerror="this.style.display='none'; console.error('Score logo failed to load.')">
             </div>
     <div class="delorean" id="delorean"
         onerror="this.style.backgroundImage='linear-gradient(grey, darkgrey)'; console.error('DeLorean image failed to load.')">
    </div>
    <div class="banner" id="banner" style="display: none;"></div>

    <div id="portal"></div>

    <div class="soundcloud-embed">
        <iframe width="100%" height="80" scrolling="no" frameborder="no" allow="autoplay"
                src="https://w.soundcloud.com/player/?url=https%3A//api.soundcloud.com/playlists/355080313&color=%23ff5500&auto_play=true&hide_related=false&show_comments=true&show_user=true&show_reposts=false&show_teaser=true&visual=false">
        </iframe>
        <div style="font-size: 10px; color: #cccccc;line-break: anywhere;word-break: normal;overflow: hidden;white-space: nowrap;text-overflow: ellipsis; font-family: Interstate,Lucida Grande,Lucida Sans Unicode,Lucida Sans,Garuda,Verdana,Tahoma,sans-serif;font-weight: 100;">
            <a href="https://soundcloud.com/psytrance-channel" title="Psytrance Channel" target="_blank" style="color: #cccccc; text-decoration: none;">Psytrance Channel</a> ·
            <a href="https://soundcloud.com/psytrance-channel/sets/full-psytrance-tracks-free" title="Full Psytrance Tracks (All Free Downloads)" target="_blank" style="color: #cccccc; text-decoration: none;">Full Psytrance Tracks (All Free Downloads)</a>
        </div>
    </div>
    <div id="pauseOverlay" class="overlay" style="display: none;">
        <div class="pause-content">
            <div class="paused-score">Score: 0</div>
            <button id="resumeButton" class="reset-button">Resume Game</button>
        </div>
    </div>
    <ul class="social-footer">
        <li>
            <a href="https://x.com/deloreanlabs?lang=en" target="_blank" aria-label="X">
                <svg width="32" height="32" viewBox="0 0 1200 1227" fill="none" xmlns="http://www.w3.org/2000/svg"> <path d="M714.163 519.284L1160.89 0H1055.03L667.137 450.887L357.328 0H0L468.492 681.821L0 1226.37H105.866L515.491 750.218L842.672 1226.37H1200L714.137 519.284H714.163ZM569.165 687.828L521.697 619.934L144.011 79.6906H311.799L569.165 687.854V687.828Z" fill="#5E6569"/>
                </svg>
            </a>
        </li>
        <li>
            <a href="https://discord.gg/deloreanlabs" target="_blank" aria-label="Discord">
                <svg width="32" height="32" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"> <path d="M20.317 4.369a19.791 19.791 0 0 0-4.885-1.515.074.074 0 0 0-.079.037c-.211.375-.444.864-.608 1.249a18.493 18.493 0 0 0-5.487 0 12.505 12.505 0 0 0-.617-1.249.077.077 0 0 0-.079-.037 19.736 19.736 0 0 0-4.885 1.515.069.069 0 0 0-.032.027C.533 9.045-.319 13.579.099 18.057a.082.082 0 0 0 .031.056 19.911 19.911 0 0 0 5.993 3.03.077.077 0 0 0 .084-.027c.462-.63.873-1.295 1.226-1.994a.076.076 0 0 0-.041-.106 13.13 13.13 0 0 1-1.872-.9.077.077 0 0 1-.008-.128c.126-.094.252-.192.373-.291a.075.075 0 0 1 .077-.01c3.927 1.793 8.18 1.793 12.062 0a.075.075 0 0 1 .079.009c.121.099.247.197.373.291a.077.077 0 0 1-.006.128 12.954 12.954 0 0 1-1.873.899.076.076 0 0 0-.04.107c.36.698.772 1.363 1.225 1.993a.076.076 0 0 0 .084.028 19.875 19.875 0 0 0 6.002-3.03.076.076 0 0 0 .031-.056c.5-5.177-.838-9.665-3.548-13.661a.061.061 0 0 0-.031-.027ZM8.02 15.803c-1.183 0-2.157-1.085-2.157-2.419 0-1.333.955-2.418 2.157-2.418 1.213 0 2.176 1.095 2.157 2.418 0 1.334-.955 2.419-2.157 2.419Zm7.963 0c-1.183 0-2.157-1.085-2.157-2.419 0-1.333.955-2.418 2.157-2.418 1.213 0 2.176 1.095 2.157 2.418 0 1.334-.944 2.419-2.157 2.419Z" fill="#5E6569"/>
                </svg>
            </a>
        </li>
        <li>
            <a href="https://github.com/donniegraham/flap-to-the-future/" target="_blank" aria-label="GitHub">
                <svg width="32" height="32" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"> <path fill-rule="evenodd" clip-rule="evenodd" fill="#5E6569" d="M12 0C5.37 0 0 5.37 0 12c0 5.31 3.435 9.795 8.205 11.385c.6.105.825-.255.825-.57c0-.285-.015-1.23-.015-2.235c-3.015.555-3.795-.735-4.035-1.41c-.135-.345-.72-1.41-1.23-1.695c-.42-.225-1.02-.78-.015-.795c.945-.015 1.62.87 1.845 1.245c1.05 1.815 2.805 1.29 3.495.99c.105-.78.42-1.29.765-1.59c-2.67-.3-5.46-1.335-5.46-5.925c0-1.305.465-2.385 1.23-3.225c-.12-.3-.54-1.53.12-3.18c0 0 1.005-.315 3.3 1.23c.96-.27 1.98-.405 3-.405s2.04.135 3 .405c2.295-1.56 3.3-1.23 3.3-1.23c.66 1.65.24 2.88.12 3.18c.765.84 1.23 1.92 1.23 3.225c0 4.605-2.805 5.625-5.475 5.925c.435.375.81 1.095.81 2.22c0 1.59-.015 2.88-.015 3.27c0 .315.225.69.825.57A12.02 12.02 0 0 0 24 12C24 5.37 18.63 0 12 0z"/>
                </svg>
            </a>
        </li>
    </ul>
    </div>

  <script>
      // --- Game Logic (Vanilla JS - Flappy Style) ---

      // Get references to HTML elements
      const delorean = document.getElementById("delorean");
      const game = document.getElementById("game");
      const scoreEl = document.getElementById("score");
      const bannerEl = document.getElementById("banner");
      const pauseButton = document.getElementById('pauseButton');
      const pauseOverlay = document.getElementById('pauseOverlay');
      // REMOVED: Fuel Bar Elements


      // --- Game Constants ---
      let gravity; // Set in initializeGame based on screen width
      const flapStrength = -7; // Upward velocity impulse on flap
      const pipeWidth = 80; // Width of obstacle pipes
      const pipeGap = 180; // Increased gap
      const boosterDuration = 200; // How long booster effect lasts in ms
      let baseGameSpeed; // Set in initializeGame based on screen width
      const baseSpawnInterval = 2400; // Starting time between spawns
      // Coin Constants
      const coinWidth = 35; // Match CSS size
      const coinHeight = 35; // Match CSS size
      // REMOVED: Fuel Constants

      // Logo URL for game over screen
      const gameOverLogoUrl =
        "https://deloreanlabs.com/_next/image?url=%2Fassets%2Fimages%2Fdmc-coin-1.png&w=1080&q=75"; // Same as score logo
      const bitcoinLogoUrl = 'https://upload.wikimedia.org/wikipedia/commons/thumb/4/46/Bitcoin.svg/1200px-Bitcoin.svg.png';
      const suiLogoUrl = 'https://assets.crypto.ro/logos/sui-sui-logo.png';
      const walLogoUrl = 'https://s2.coinmarketcap.com/static/img/coins/64x64/36119.png'; // Updated URL

      // --- Game State Variables ---
      let playerY; // Vertical position (top of DeLorean)
      let playerVelocityY; // Vertical velocity
      let playerWidth; // Store player dimensions
      let playerHeight;
      let obstacles = []; // Array holds {topEl, bottomEl, x, width, itemEl, itemType, itemCollected, isBonus, gapY, topHeight, bottomHeight, oscillationPhase}
      let score;
      let topScore = 0; // Track top score
      let lastSpawnTime = 0;
      let gameActive = false; // Start inactive
      let animationFrameId;
      let boosterTimeoutId = null; // To manage the booster effect timeout
      let tiltTimeoutId = null; // Timeout ID for tilt reset
      let gameSpeed; // Current horizontal speed (now using let)
      let spawnInterval; // Current spawn interval (now using let)
      let currentObstacleColor1 = '#2c3e50';
      let currentObstacleColor2 = '#1a2531';
      let currentObstacleGlow = 'rgba(0, 255, 255, 0.6)';
      let isPaused = false; // Pause State
      // REMOVED: Fuel State Variable
      let lastTimeRef = null; // For delta time calculation
      // Obstacle Oscillation State
      let obstaclesShouldOscillate = false;
      let obstaclesSinceLastOscillationToggle = 0;


      // --- Named event handlers ---
      const startGameHandler = () => startGameHandlerFunc();


      // --- Initialization ---
      function initializeGame() {
        console.log("--- Running initializeGame ---");

        // Adjust physics based on screen width
        const mobileBreakpoint = 768;
        if (window.innerWidth < mobileBreakpoint) {
            gravity = 0.3; baseGameSpeed = 2.5;
        } else {
            gravity = 0.4; baseGameSpeed = 3;
        }

        playerWidth = delorean.offsetWidth;
        playerHeight = delorean.offsetHeight;
        playerY = window.innerHeight / 2 - playerHeight / 2;
        playerVelocityY = 0;
        score = 0;
        obstacles = [];
        lastSpawnTime = 0;
        gameActive = false;
        isPaused = false;
        if (pauseOverlay) pauseOverlay.style.display = 'none';
        gameSpeed = baseGameSpeed;
        spawnInterval = baseSpawnInterval;
        currentObstacleColor1 = '#2c3e50';
        currentObstacleColor2 = '#1a2531';
        currentObstacleGlow = 'rgba(0, 255, 255, 0.6)';
        obstaclesShouldOscillate = false; // Reset oscillation state
        obstaclesSinceLastOscillationToggle = 0; // Reset oscillation counter
        scoreEl.textContent = score;
        delorean.style.transition = 'none';
        delorean.style.opacity = '0';
        delorean.style.left = '0px';
        delorean.style.transform = 'translateX(0) rotate(0deg)';
        delorean.style.top = `${playerY}px`;

        delorean.classList.remove("booster-active");
        if (boosterTimeoutId) clearTimeout(boosterTimeoutId);
        if (tiltTimeoutId) clearTimeout(tiltTimeoutId);
        lastTimeRef = null;

        document.querySelectorAll(".obstacle-pipe").forEach((pipe) => {
            pipe.style.transform = 'translateY(0px)'; // Reset transform on pipes
            pipe.remove();
        });
        document.querySelectorAll(".coin, .bitcoin-coin, .sui-coin, .wal-coin, .lofi-coin").forEach((item) => item.remove());
        bannerEl.innerHTML = "Click or Press Space to Flap!";
        bannerEl.style.display = "block";

        const portalEl = document.getElementById('portal');
        if (portalEl) {
            portalEl.style.display = 'block';
            portalEl.classList.remove('portal-closing');
            portalEl.style.opacity = '1';
            portalEl.style.transform = 'translateY(-50%) scale(1)';
        }

        bannerEl.removeEventListener('click', initializeGame);
        bannerEl.removeEventListener('click', startGameHandler);
        bannerEl.addEventListener('click', startGameHandler);
        console.log("Added startGameHandler listener to banner");

        const resetButton = document.getElementById('resetButton');
        if (resetButton) {
            const newButton = resetButton.cloneNode(true);
            if (resetButton.parentNode) {
                 resetButton.parentNode.replaceChild(newButton, resetButton);
            }
        }
         const shareButton = document.getElementById('shareButton');
         if (shareButton) {
             const newShareButton = shareButton.cloneNode(true);
             if (shareButton.parentNode) {
                 shareButton.parentNode.replaceChild(newShareButton, shareButton);
             }
         }

        topScore = parseInt(localStorage.getItem('flappyTopScore') || '0');
        console.log("Loaded Top Score:", topScore);
        console.log("Player Y reset to:", playerY);
        console.log("Obstacles cleared:", obstacles.length);

        if (window.resetBackground) { window.resetBackground(); }
        else { console.warn("window.resetBackground function not found."); }

         setTimeout(() => {
            if(delorean) {
               delorean.style.transition = 'left 1s cubic-bezier(0.25, 1, 0.5, 1), opacity 0.5s ease-in, transform 0.4s ease-out';
            }
         }, 10);
      }


      // --- Handler function for starting ---
      function startGameHandlerFunc() {
          if (gameActive || isPaused) return;
          console.log("--- Running startGameHandler (Start Triggered) ---");

          bannerEl.removeEventListener('click', startGameHandler);
          console.log("Removed startGameHandler listener from banner");

          const portalEl = document.getElementById('portal');
          if (portalEl) portalEl.classList.add('portal-closing');

          bannerEl.style.display = 'none';

          console.log("--- Starting game immediately ---");
          playerWidth = delorean.offsetWidth;
          playerHeight = delorean.offsetHeight;
          gameActive = true;
          lastSpawnTime = performance.now();
          lastTimeRef = performance.now(); // Initialize lastTimeRef for delta time

          delorean.style.transition = 'left 1s cubic-bezier(0.25, 1, 0.5, 1), opacity 0.5s ease-in, transform 0.4s ease-out';
          requestAnimationFrame(() => {
                delorean.style.opacity = '1';
                delorean.style.left = '50%';
                delorean.style.transform = 'translateX(-50%) rotate(0deg)';
          });

          flap(); // Initial flap
          if (!animationFrameId) {
             animationFrameId = requestAnimationFrame(gameLoop);
          }
          console.log("gameActive set to:", gameActive);
      }


      // --- Functions ---
      function flap() {
        if (!gameActive || isPaused) { return; }

        // REMOVED: Fuel Check/Depletion

        playerVelocityY = flapStrength;

        // Apply tilt transform
        delorean.style.transform = 'translateX(-50%) rotate(-10deg)';
        if (tiltTimeoutId) clearTimeout(tiltTimeoutId);
        tiltTimeoutId = setTimeout(() => {
            if (gameActive && !isPaused) {
                 delorean.style.transform = 'translateX(-50%) rotate(10deg)';
            }
            tiltTimeoutId = null;
        }, 150);


        // Booster effect
        delorean.classList.add("booster-active");
        if (boosterTimeoutId) { clearTimeout(boosterTimeoutId); }
        boosterTimeoutId = setTimeout(() => {
          delorean.classList.remove("booster-active");
          boosterTimeoutId = null;
        }, boosterDuration);
      }

      // Helper to get random futuristic colors
      function getRandomFuturisticColors() {
          const hue = Math.random() * 360;
          const saturation = 70 + Math.random() * 20;
          const lightness1 = 40 + Math.random() * 15;
          const lightness2 = lightness1 - 15;
          const glowLightness = 60 + Math.random() * 10;
          return {
              color1: `hsl(${hue}, ${saturation}%, ${lightness1}%)`,
              color2: `hsl(${hue}, ${saturation}%, ${lightness2}%)`,
              glowColor: `hsla(${hue}, ${saturation + 10}%, ${glowLightness}%, 0.7)`
          };
      }

      function spawnObstacle() {
        const minGapY = pipeGap / 2 + 50;
        const maxGapY = window.innerHeight - pipeGap / 2 - 50;
        const gapY = Math.random() * (maxGapY - minGapY) + minGapY;
        const topPipeHeight = gapY - pipeGap / 2;
        const bottomPipeHeight = window.innerHeight - (gapY + pipeGap / 2);

        const obstacleTop = document.createElement("div");
        obstacleTop.classList.add("obstacle-pipe", "obstacle-top");
        obstacleTop.style.left = `${window.innerWidth}px`;
        obstacleTop.style.height = `${topPipeHeight}px`;

        const obstacleBottom = document.createElement("div");
        obstacleBottom.classList.add("obstacle-pipe", "obstacle-bottom");
        obstacleBottom.style.left = `${window.innerWidth}px`;
        obstacleBottom.style.height = `${bottomPipeHeight}px`;

        // Apply current colors
        const gradient = `linear-gradient(to bottom, ${currentObstacleColor1}, ${currentObstacleColor2})`;
        const glowBaseAlpha = parseFloat(currentObstacleGlow.split(',')[3] || '0.6');
        const shadow = `0 0 5px ${currentObstacleGlow}, 0 0 10px ${currentObstacleGlow.replace(/[\d\.]+\)/, (glowBaseAlpha * 0.66).toFixed(2) + ')')}`;

        obstacleTop.style.backgroundImage = gradient;
        obstacleTop.style.boxShadow = shadow;
        obstacleBottom.style.backgroundImage = gradient;
        obstacleBottom.style.boxShadow = shadow;

        game.appendChild(obstacleTop);
        game.appendChild(obstacleBottom);

        // Spawn Coin (maybe bonus)
        let itemEl = null;
        let itemType = null; // 'coin', 'bitcoin', 'sui', 'wal', 'lofi'
        let isBonus = false;
        const itemRoll = Math.random();
        const bonusCoinChance = 0.25; // 25% Bonus Coin (BTC/SUI/WAL/LOFI)
        const normalCoinChance = 0.6; // 60% Normal Coin (DMC)
        // Remaining 15% is nothing

        let itemX = window.innerWidth + pipeWidth / 2; // Base horizontal position
        let itemY = gapY; // Base vertical position
        let itemClass = '';
        let currentItemWidth = coinWidth; // Default to coin size
        let currentItemHeight = coinHeight;

        if (itemRoll < bonusCoinChance) { // Spawn Bonus Coin
            isBonus = true;
            const bonusRoll = Math.random();
            if (bonusRoll < 0.25) { itemType = 'bitcoin'; }
            else if (bonusRoll < 0.50) { itemType = 'sui'; }
            else if (bonusRoll < 0.75) { itemType = 'wal'; }
            else { itemType = 'lofi'; }
            itemClass = `${itemType}-coin`;

            // Position Bonus Coin Outside Gap
            const verticalOffset = 15;
            itemY = (Math.random() < 0.5)
                ? (topPipeHeight + verticalOffset)
                : (window.innerHeight - bottomPipeHeight - currentItemHeight - verticalOffset);
            itemY = Math.max(10, Math.min(window.innerHeight - currentItemHeight - 10, itemY));
            // console.log(`Spawned Bonus Coin: ${itemType}`);

        } else if (itemRoll < bonusCoinChance + normalCoinChance) { // Spawn Normal Coin
            itemType = 'coin';
            isBonus = false;
            itemClass = 'coin';
            itemY = gapY - currentItemHeight / 2; // Center in gap
            // console.log("Spawned Regular Coin");
        } // Else: nothing spawns

        // Create and append element if an item type was chosen
        if (itemType) {
            itemEl = document.createElement("div");
            itemEl.classList.add(itemClass);
            itemX = window.innerWidth + pipeWidth / 2 - currentItemWidth / 2; // Final X calc
            itemEl.style.left = `${itemX}px`;
            itemEl.style.top = `${itemY}px`;
            game.appendChild(itemEl);
        }

        // Add obstacle pair details to array, including item info
        obstacles.push({
          topEl: obstacleTop,
          bottomEl: obstacleBottom,
          x: window.innerWidth,
          width: pipeWidth,
          itemEl: itemEl,
          itemType: itemType,
          itemCollected: itemType === null,
          isBonus: isBonus,
          gapY: gapY,
          topHeight: topPipeHeight,
          bottomHeight: bottomPipeHeight,
          oscillationPhase: Math.random() * Math.PI * 2 // Add random phase for oscillation
        });

        // Toggle Obstacle Oscillation
        if (score >= 10) { // Start checking after score 10
            obstaclesSinceLastOscillationToggle++;
            if (obstaclesSinceLastOscillationToggle >= 10) {
                obstaclesShouldOscillate = !obstaclesShouldOscillate; // Toggle state
                obstaclesSinceLastOscillationToggle = 0; // Reset counter
                console.log(`Obstacle oscillation toggled: ${obstaclesShouldOscillate}`);
            }
        }
      }

      // Collision check function
      function checkCollision(rect1, rect2) {
        const horizontalPadding = 10; // Smaller hitbox
        const verticalPadding = 10;   // Smaller hitbox
        return (
          rect1.left + horizontalPadding < rect2.right &&
          rect1.right - horizontalPadding > rect2.left &&
          rect1.top + verticalPadding < rect2.bottom &&
          rect1.bottom - verticalPadding > rect2.top
        );
      }

      function gameOver() {
        console.log("--- Running gameOver ---");
        gameActive = false;
        isPaused = false; // Ensure not paused if game over
        if(animationFrameId) cancelAnimationFrame(animationFrameId);
        animationFrameId = null;
        delorean.classList.remove("booster-active");
        if (boosterTimeoutId) clearTimeout(boosterTimeoutId);
        if (tiltTimeoutId) clearTimeout(tiltTimeoutId);
        obstaclesShouldOscillate = false; // Reset oscillation state on game over
        obstaclesSinceLastOscillationToggle = 0; // Reset oscillation counter

        // Update and save top score
        if (score > topScore) {
            topScore = score;
            localStorage.setItem('flappyTopScore', topScore);
            console.log("New Top Score!", topScore);
        }

        // Set banner innerHTML for Score + Top Score + Buttons
        bannerEl.innerHTML = `
            <div class="banner-text-content">
                 <div class="current-score">Score: ${score}</div>
                 <div class="top-score">Top Score: ${topScore}</div>
                 </div>
             <button id="resetButton" class="reset-button">
                 <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M21.5 2v6h-6M2.5 22v-6h6M2 12a10 10 0 0 1 18.19-5.39L21.5 2M22 12a10 10 0 0 1-18.19 5.39L2.5 22"/>
                 </svg>
                 Go back to the future
             </button>
             <button id="shareButton" class="share-button" aria-label="Share on X">
                 Share my score
                 <svg viewBox="0 0 1200 1227" fill="none" xmlns="http://www.w3.org/2000/svg">
                     <path d="M714.163 519.284L1160.89 0H1055.03L667.137 450.887L357.328 0H0L468.492 681.821L0 1226.37H105.866L515.491 750.218L842.672 1226.37H1200L714.137 519.284H714.163ZM569.165 687.828L521.697 619.934L144.011 79.6906H311.799L569.165 687.854V687.828Z"/>
                 </svg>
             </button>
        `;

        bannerEl.style.display = "block";
        bannerEl.onclick = null;
        if (pauseOverlay) pauseOverlay.style.display = 'none';

        // Add listener to the reset button
        const resetButton = document.getElementById('resetButton');
        if (resetButton) {
            const tempResetHandler = () => {
                 resetButton.removeEventListener('click', tempResetHandler);
                 initializeGame();
            };
            resetButton.addEventListener('click', tempResetHandler);
            console.log("Added click listener to reset button");
        } else {
            console.error("Reset button not found");
        }

        // Add listener to the share button
        const shareButton = document.getElementById('shareButton');
        if (shareButton) {
            const shareText = `I scored ${score} in Flap to the Future! The Future begins Now! @deloreanlabs #FlapToTheFuture`; // Updated game name
            const shareUrl = 'https://dmc-game.wal.app/';
            const twitterIntentUrl = `https://twitter.com/intent/tweet?text=${encodeURIComponent(shareText)}&url=${encodeURIComponent(shareUrl)}`;

            const tempShareHandler = () => {
                window.open(twitterIntentUrl, '_blank');
            };
            const newShareButton = shareButton.cloneNode(true);
            if (shareButton.parentNode) {
                 shareButton.parentNode.replaceChild(newShareButton, shareButton);
                 newShareButton.addEventListener('click', tempShareHandler);
            } else {
                 console.error("Share button parent node not found");
            }
        } else {
            console.error("Share button not found");
        }
      }

      // --- Pause and Resume Functions ---
      function pauseGame() {
          if (!gameActive) return;
          isPaused = true;
          gameActive = false;
          if (animationFrameId) cancelAnimationFrame(animationFrameId);
          animationFrameId = null;

          const pausedScoreEl = pauseOverlay.querySelector('.paused-score');
          if (pausedScoreEl) pausedScoreEl.textContent = `Score: ${score}`;
          if (pauseOverlay) pauseOverlay.style.display = 'flex';
          console.log("Game Paused");
      }

      function resumeGame() {
          if (!isPaused) return;
          isPaused = false;
          gameActive = true;
          if (pauseOverlay) pauseOverlay.style.display = 'none';

          if (!animationFrameId) {
               console.log("Resuming game loop");
               // Reset lastTimeRef to prevent large jump after pause
               lastTimeRef = performance.now(); // Reset timer reference
               animationFrameId = requestAnimationFrame(gameLoop);
          }
          console.log("Game Resumed");
      }


      function gameLoop(currentTime) {
        if (!gameActive) return; // Skips loop if paused or game over

        // Calculate time delta for smoother physics
        const deltaTime = currentTime - (lastTimeRef || currentTime);
        lastTimeRef = currentTime; // Assign to variable directly
        const effectiveDeltaTime = Math.min(deltaTime, 32); // Cap delta time
        const multiplier = effectiveDeltaTime / (1000 / 60); // Adjust physics based on 60fps target


        // Player Physics
        playerVelocityY += gravity * multiplier; // Apply gravity using multiplier
        playerY += playerVelocityY * multiplier; // Apply velocity using multiplier
        delorean.style.top = `${playerY}px`;

        // Ground/Ceiling Collision
        if (playerY <= 0) {
          playerY = 0; playerVelocityY = Math.max(0, playerVelocityY); gameOver(); return;
        }
        if (playerY + playerHeight >= window.innerHeight) {
          playerY = window.innerHeight - playerHeight; gameOver(); return;
        }

        // Obstacle and Item Management
        const playerRect = delorean.getBoundingClientRect();
        let justScored = false; // Flag to check if score increased this frame

        for (let i = obstacles.length - 1; i >= 0; i--) {
          const obs = obstacles[i];
          obs.x -= gameSpeed * multiplier; // Move obstacle data point using multiplier

          // Calculate and Apply Obstacle Oscillation
          let currentVerticalOffset = 0;
          if (obstaclesShouldOscillate) { // Check the flag
              const oscillationAmplitude = 25; // Max pixels up/down
              const oscillationFrequency = 0.006; // Speed of oscillation relative to x pos
              currentVerticalOffset = oscillationAmplitude * Math.sin(obs.x * oscillationFrequency + obs.oscillationPhase);
          }
          // Apply vertical offset using transform
          obs.topEl.style.transform = `translateY(${currentVerticalOffset}px)`;
          obs.bottomEl.style.transform = `translateY(${currentVerticalOffset}px)`;


          // Update pipe horizontal positions
          obs.topEl.style.left = `${obs.x}px`;
          obs.bottomEl.style.left = `${obs.x}px`;

          // Update Item Position & Check Collection
          if (obs.itemEl && !obs.itemCollected) {
            const itemWidth = (obs.itemType && obs.itemType.includes('coin')) ? coinWidth : 0; // Get width based on type (coin or bonus coin)
            const itemHeight = (obs.itemType && obs.itemType.includes('coin')) ? coinHeight : 0;
            const itemX = obs.x + pipeWidth / 2 - itemWidth / 2; // Center item horizontally with pipe
            let itemY;

            if (obs.isBonus) { // Position bonus coins relative to moving pipe edges
                const verticalOffsetMargin = 15;
                const currentTopPipeBottomEdge = obs.topHeight + currentVerticalOffset;
                const currentBottomPipeTopEdge = window.innerHeight - obs.bottomHeight + currentVerticalOffset;
                const spawnedLow = obs.gapY > window.innerHeight / 2;

                itemY = spawnedLow
                    ? (currentBottomPipeTopEdge - itemHeight - verticalOffsetMargin)
                    : (currentTopPipeBottomEdge + verticalOffsetMargin);

                itemY = Math.max(10, Math.min(window.innerHeight - itemHeight - 10, itemY)); // Clamp
            } else { // Normal items stay centered in the (moving) gap center
                itemY = obs.gapY - itemHeight / 2 + currentVerticalOffset; // Add offset here too
            }

            obs.itemEl.style.left = `${itemX}px`;
            obs.itemEl.style.top = `${itemY}px`; // Apply calculated Y

            const itemRect = obs.itemEl.getBoundingClientRect();
            if (checkCollision(playerRect, itemRect)) {
                if (obs.itemType === 'coin' || obs.itemType === 'bitcoin' || obs.itemType === 'sui' || obs.itemType === 'wal' || obs.itemType === 'lofi') { // Check all coin types
                    let points = 1; // --- MODIFIED: All coins worth 1 point ---
                    score += points;
                    scoreEl.textContent = score;
                    justScored = true;
                    console.log(`${obs.itemType} collected! +${points} point(s). Score: ${score}`);

                    // REMOVED: Fuel refill on coin collect

                    // Check for obstacle color change (every 5 points)
                    if (score > 0 && score % 5 === 0) {
                        const newColors = getRandomFuturisticColors();
                        currentObstacleColor1 = newColors.color1;
                        currentObstacleColor2 = newColors.color2;
                        currentObstacleGlow = newColors.glowColor;
                        console.log(`Score milestone ${score}: Obstacle colors changing!`);
                    }
                }
                // REMOVED: Fuel can collection logic

                obs.itemCollected = true;
                obs.itemEl.remove();
                obs.itemEl = null;
                obs.itemType = null;
            }
          }

          // Check Pipe Collision AFTER item check
          const topPipeRect = obs.topEl.getBoundingClientRect();
          const bottomPipeRect = obs.bottomEl.getBoundingClientRect();
          if (
            !obs.itemCollected && // Don't check pipe collision if item was just collected this frame
            (checkCollision(playerRect, topPipeRect) ||
            checkCollision(playerRect, bottomPipeRect))
          ) {
            gameOver();
            return;
          }

          // Remove Off-screen Obstacles
          if (obs.x < -obs.width) {
            obs.topEl.remove();
            obs.bottomEl.remove();
            if (obs.itemEl) {
              obs.itemEl.remove();
            }
            obstacles.splice(i, 1);
          }
        }

       // Difficulty Increase (Triggered AFTER loop if score increased)
       if (justScored && score > 0 && score % 3 === 0) { // Increase difficulty every 3 points
            let speedIncrease = 0.15 + Math.floor(score / 25) * 0.1; // Keep magnitude same for now
            gameSpeed += speedIncrease;
            let intervalReductionFactor = 0.98 - Math.floor(score / 50) * 0.015; // Keep magnitude same
            intervalReductionFactor = Math.max(0.80, intervalReductionFactor);
            spawnInterval = Math.max(800, spawnInterval * intervalReductionFactor);
            console.log(`Score Milestone: ${score} (every 3), Speed Inc: +${speedIncrease.toFixed(2)}, New Speed: ${gameSpeed.toFixed(1)}, Interval Factor: ${intervalReductionFactor.toFixed(2)}, New Interval: ${spawnInterval.toFixed(0)}ms`);
       }


      // Spawning New Obstacles
      if (currentTime - lastSpawnTime > spawnInterval) {
        spawnObstacle();
        lastSpawnTime = currentTime;
      }

      animationFrameId = requestAnimationFrame(gameLoop);
    }


      // Event Listeners
      game.addEventListener("pointerdown", flap);
      // Keydown listener only for flapping and pause/resume
      window.addEventListener("keydown", (e) => {
        if (e.code === "Space") {
          e.preventDefault();
          if (gameActive) {
            flap();
          }
          // No longer resets on space when game over
        }
        if (e.code === 'KeyP') { // Use 'P' to pause/resume
             if (gameActive) {
                 pauseGame();
             } else if (isPaused) {
                 resumeGame();
             }
        }
      });

      // Add Listeners for Pause/Resume Buttons
      if (pauseButton) {
          pauseButton.addEventListener('click', pauseGame);
      } else {
          console.error("Pause button not found!");
      }
      // Add listener for resume button after DOM is loaded
       document.addEventListener('DOMContentLoaded', () => {
            const resumeBtn = document.getElementById('resumeButton');
            if (resumeBtn) {
                resumeBtn.addEventListener('click', resumeGame);
                console.log("Resume button listener added.");
            }
       });


      // Initial Setup
      // initializeMusic(); // Music init removed
      initializeGame(); // Then set initial game state

    </script>

    <script>
      // --- p5.js Space Background (Simplified - No Logos) ---

      let starsFar = [];
      let starsMid = [];
      let starsNear = [];
      // Reduced star counts for performance
      let numStarsFar = 100;
      let numStarsMid = 70;
      let numStarsNear = 30;

      // Function to initialize a single star layer
      function initializeStars(starArray, numStars) {
        starArray.length = 0;
        for (let i = 0; i < numStars; i++) {
          starArray.push({
            x: random(-width * 1.5, width * 1.5),
            y: random(-height * 1.5, height * 1.5),
            z: random(width),
          });
        }
      }

      // Define resetBackground in the script scope
      function resetBackground() {
        console.log("Resetting background stars");
        // Check if p5 functions are available
        if (
          typeof initializeStars === "function" &&
          typeof width !== "undefined"
        ) {
          // Check width too
          initializeStars(starsFar, numStarsFar);
          initializeStars(starsMid, numStarsMid);
          initializeStars(starsNear, numStarsNear);
        } else {
          console.warn(
            "p5 functions/vars not ready during resetBackground call?"
          );
        }
      }

      function setup() {
        let cnv = createCanvas(window.innerWidth, window.innerHeight);
        cnv.style("display", "block");
        cnv.parent(document.body);
        cnv.style("position", "absolute");
        cnv.style("top", "0");
        cnv.style("left", "0");
        cnv.style("z-index", "0");

        resetBackground(); // Call reset once here to do initial setup

        // Assign the globally defined function to window
        window.resetBackground = resetBackground;
      }

      // Function to update and draw a star layer
      function drawStarLayer(starArray, factor, minSize, maxSize, baseSpeed) {
        for (let i = starArray.length - 1; i >= 0; i--) {
          let star = starArray[i];
          // Use global gameSpeed from main script
          let currentSpeedFactor = (typeof gameSpeed !== 'undefined') ? gameSpeed : baseGameSpeed;
          if (gameActive) { // Check gameActive flag from main script
            star.z -= baseSpeed * factor * (currentSpeedFactor * 0.5 + 0.5); // Link speed to gameSpeed
          }
          if (star.z < 1) {
            star.x = random(-width * 1.5, width * 1.5);
            star.y = random(-height * 1.5, height * 1.5);
            star.z = random(width * 0.8, width);
          }
          let sx = map(star.x / star.z, -1, 1, 0, width);
          let sy = map(star.y / star.z, -1, 1, 0, height);
          let r = map(star.z, 0, width, maxSize, minSize);
          let alpha = map(star.z, 0, width, 255, 50);
          let brightness = map(star.z, 0, width, 255, 150);
          let starColor = color(brightness, alpha);
          if (random() < 0.05) starColor = color(200, 200, 255, alpha * 0.8);
          else if (random() < 0.05)
            starColor = color(255, 255, 200, alpha * 0.8);
          fill(starColor);
          noStroke();
          // Add check for sx, sy being valid numbers before drawing
          if (
            isFinite(sx) &&
            isFinite(sy) &&
            sx > -width &&
            sx < width * 2 &&
            sy > -height &&
            sy < height * 2
          ) {
            ellipse(sx, sy, r, r);
          }
        }
      }

      function draw() {
        background(0, 0, 15); // Very dark blue/black background

        // Draw regular star layers
        drawStarLayer(starsFar, 0.2, 0.5, 1.5, 0.5);
        drawStarLayer(starsMid, 0.5, 1, 3, 0.8);
        drawStarLayer(starsNear, 1.0, 2, 5, 1.2);
      }

      function windowResized() {
        resizeCanvas(window.innerWidth, window.innerHeight);
        // Call resetBackground directly
        if (!gameActive) { // Use global gameActive state
          resetBackground();
        }
      }
    </script>
  </body>
</html>
